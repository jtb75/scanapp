// in upload.go
package vulnerability

import (
	"encoding/json"
	"os"
)

// OpenHistoricalState looks for the file "state-historical.json" and opens it if it exists.
// If it doesn't exist, it returns an empty VulnerabilityOutput struct.
func OpenHistoricalState() (*VulnerabilityOutput, error) {
	// Define the path to the file
	filepath := "state-historical.json" // Update with actual path

	// Check if the file exists
	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		// File does not exist, return the predefined structure
		return &VulnerabilityOutput{
			IntegrationID: "",
			DataSources: []DataSource{
				{
					ID:           "",
					AnalysisDate: "",
					Assets: []Asset{
						{
							AssetIdentifier: AssetIdentifier{
								CloudPlatform: "",
								ProviderId:    "",
							},
							VulnerabilityFindings: []VulnerabilityFinding{},
						},
					},
				},
			},
		}, nil
	} else if err != nil {
		// An error occurred trying to obtain the file info
		return nil, err
	}

	// Read the file content
	fileContent, err := os.ReadFile(filepath)
	if err != nil {
		// An error occurred reading the file
		return nil, err
	}

	// Initialize an empty VulnerabilityOutput to unmarshal the content into
	historicalState := &VulnerabilityOutput{}

	// Unmarshal the content into the historicalState
	err = json.Unmarshal(fileContent, historicalState)
	if err != nil {
		// An error occurred during unmarshalling
		return nil, err
	}

	// Return the populated or empty historicalState
	return historicalState, nil
}

// WriteHistoricalState writes the given VulnerabilityOutput to a file as JSON.
func WriteHistoricalState(historicalState *VulnerabilityOutput) error {
	// Convert the historicalState to JSON
	data, err := json.MarshalIndent(historicalState, "", "  ")
	if err != nil {
		return err
	}

	// Define the file path
	filepath := "state-historical.json"

	// Write the JSON data to the file
	err = os.WriteFile(filepath, data, 0644)
	if err != nil {
		return err
	}

	return nil
}

// WriteCurrentState writes the current state to a file.
func WriteCurrentState(currentState *VulnerabilityOutput) error {
	// Convert the currentState to JSON
	data, err := json.MarshalIndent(currentState, "", "  ")
	if err != nil {
		return err // Return the error if marshaling fails
	}

	// Define the file path
	filePath := "state-current.json"

	// Write the data to the file
	err = os.WriteFile(filePath, data, 0644) // Use appropriate file permissions
	if err != nil {
		return err // Return the error if writing to the file fails
	}

	// If everything is successful, return nil (no error)
	return nil
}

// UpdateHistoricalState updates the historical state with new vulnerabilities from the current state
func UpdateHistoricalState(historicalState, currentState *VulnerabilityOutput) (*VulnerabilityOutput, error) {
	// Create a map for quick lookups from historicalState
	historicalVulnerabilityMap := make(map[string]bool)

	// Populate the map with data from historicalState
	for _, asset := range historicalState.DataSources[0].Assets {
		for _, vuln := range asset.VulnerabilityFindings {
			historicalVulnerabilityMap[vuln.Description] = true
		}
	}

	// Loop through the vulnerability findings in currentState
	for _, asset := range currentState.DataSources[0].Assets {
		for _, vuln := range asset.VulnerabilityFindings {
			if _, exists := historicalVulnerabilityMap[vuln.Description]; !exists {
				// This vulnerability is not in historicalState, so add it
				historicalState.DataSources[0].Assets[0].VulnerabilityFindings = append(historicalState.DataSources[0].Assets[0].VulnerabilityFindings, vuln)
				// Update the map
				historicalVulnerabilityMap[vuln.Description] = true
			}
		}
	}

	return historicalState, nil
}

func OpenCurrentState() (*VulnerabilityOutput, error) {
	// Define the path to the file
	filepath := "state-current.json" // Update with actual path

	// Read the file content
	fileContent, err := os.ReadFile(filepath)
	if err != nil {
		// An error occurred reading the file
		return nil, err
	}

	// Initialize an empty VulnerabilityOutput to unmarshal the content into
	currentState := &VulnerabilityOutput{}

	// Unmarshal the content into the historicalState
	err = json.Unmarshal(fileContent, currentState)
	if err != nil {
		// An error occurred during unmarshalling
		return nil, err
	}

	// Return the populated or empty historicalState
	return currentState, nil
}
