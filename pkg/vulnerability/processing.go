// in processing.go
package vulnerability

import (
	"encoding/json"
	"fmt"
	"scanapp/pkg/config"
	"time"
)

type ScanData struct {
	Result struct {
		Libraries    []Library `json:"libraries"`
		OsPackages   []Library `json:"osPackages"`
		Applications []Library `json:"applications"`
		Cpes         []Library `json:"cpes"`
	} `json:"result"`
}

type Library struct {
	Name            string          `json:"name"`
	Version         string          `json:"version"`
	Path            string          `json:"path"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	DetectionMethod string          `json:"detectionMethod"`
}

type Cpes struct {
	Name            string          `json:"name"`
	Version         string          `json:"version"`
	Path            string          `json:"path"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	DetectionMethod string          `json:"detectionMethod"`
}

type Applications struct {
	Name            string          `json:"name"`
	Version         string          `json:"version"`
	Path            string          `json:"path"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	DetectionMethod string          `json:"detectionMethod"`
}

type OsPackages struct {
	Name            string          `json:"name"`
	Version         string          `json:"version"`
	Path            string          `json:"path"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	DetectionMethod string          `json:"detectionMethod"`
}

type Vulnerability struct {
	Name                string  `json:"name"`
	Severity            string  `json:"severity"`
	FixedVersion        string  `json:"fixedVersion"`
	Source              string  `json:"source"`
	Score               float64 `json:"score"`
	ExploitabilityScore float64 `json:"exploitabilityScore"`
}

// State represents the top-level structure of your JSON data to be uploaded
type VulnerabilityOutput struct {
	IntegrationID string       `json:"integrationId"`
	DataSources   []DataSource `json:"dataSources"`
}

// DataSource represents each item in the "dataSources" array
type DataSource struct {
	ID           string  `json:"id"`
	AnalysisDate string  `json:"analysisDate"`
	Assets       []Asset `json:"assets"`
}

// Asset represents each item in the "assets" array
type Asset struct {
	AssetIdentifier       AssetIdentifier        `json:"assetIdentifier"`
	VulnerabilityFindings []VulnerabilityFinding `json:"vulnerabilityFindings"`
}

// AssetIdentifier represents the "assetIdentifier" object
type AssetIdentifier struct {
	CloudPlatform string `json:"cloudPlatform"`
	ProviderId    string `json:"providerId"`
}

// VulnerabilityFinding represents each item in the "vulnerabilityFindings" array
type VulnerabilityFinding struct {
	ID                      string `json:"id"`
	Name                    string `json:"name"`
	DetailedName            string `json:"detailedName"`
	ExternalDetectionSource string `json:"externalDetectionSource"`
	Severity                string `json:"severity"`
	ExternalFindingLink     string `json:"externalFindingLink"`
	Version                 string `json:"version"`
	Source                  string `json:"source"`
	Remediation             string `json:"remediation"`
	FixedVersion            string `json:"fixedVersion"`
	ValidatedAtRuntime      bool   `json:"validatedAtRuntime"`
	Description             string `json:"description"`
}

// ProcessVulnerabilities takes a slice of JSON strings and processes the vulnerabilities.
func ProcessVulnerabilities(jsonOutputs []string, cfg *config.Config, historicalState *VulnerabilityOutput) (*VulnerabilityOutput, error) {

	// Initialize nextId to 1
	nextId := 1

	// Build a map of historical vulnerability findings for quick comparisons
	historicalVulnerabilitiesMap := make(map[string]string)

	if historicalState != nil && len(historicalState.DataSources) > 0 {
		for _, asset := range historicalState.DataSources[0].Assets {
			for _, vuln := range asset.VulnerabilityFindings {
				historicalVulnerabilitiesMap[vuln.Description] = vuln.ID
			}
		}
	}

	// Count the existing VulnerabilityFindings in historicalState
	if historicalState != nil && len(historicalState.DataSources) > 0 {
		for _, asset := range historicalState.DataSources[0].Assets {
			nextId += len(asset.VulnerabilityFindings)
		}
	}

	vulnerabilityOutput := &VulnerabilityOutput{
		IntegrationID: "e7ddcf48-a2f3-fd39-89f4-b27c4efca17c", // or however you're obtaining this
		DataSources:   []DataSource{},
	}

	// Get the current time in UTC and format it
	currentTime := time.Now().UTC().Format(time.RFC3339)

	// Dummy data for DataSource, replace with your actual logic to obtain these
	dataSource := DataSource{
		ID:           cfg.ScanSubscriptionID,
		AnalysisDate: currentTime, // Set to the current time
		Assets:       []Asset{},   // Assets will be filled later
	}

	// Create a single asset for all vulnerabilities
	asset := Asset{
		AssetIdentifier: AssetIdentifier{
			CloudPlatform: cfg.ScanCloudType,  // Use the cloud platform from cfg
			ProviderId:    cfg.ScanProviderID, // Use the provider ID from cfg
		},
		VulnerabilityFindings: []VulnerabilityFinding{},
	}

	// Iterate through each json output
	for _, jsonString := range jsonOutputs {
		var scanData ScanData
		err := json.Unmarshal([]byte(jsonString), &scanData)
		if err != nil {
			return nil, fmt.Errorf("error unmarshaling json: %v", err)
		}

		// Accumulate vulnerabilities from different sections
		for _, section := range []struct {
			Label           string
			Vulnerabilities []Library
		}{
			{"libraries", scanData.Result.Libraries},
			{"osPackages", scanData.Result.OsPackages},
			{"applications", scanData.Result.Applications},
			{"cpes", scanData.Result.Cpes},
		} {
			for _, item := range section.Vulnerabilities {
				for _, vuln := range item.Vulnerabilities {
					// Build a unique description or identifier if needed
					description := fmt.Sprintf("The %s %s version %s was detected in %s.  It is vulnerable to %s, which exists in versions <%s.  The vulnerability was found in the %s with vendor severity of %s", item.DetectionMethod, item.Name, item.Version, item.Path, vuln.Name, vuln.FixedVersion, item.DetectionMethod, vuln.Severity)

					// Check if this finding already exists in historicalState
					id, exists := historicalVulnerabilitiesMap[description]
					if !exists {
						// Assign a new ID and increment nextId
						id = fmt.Sprintf("%d", nextId)
						nextId++
					}

					// Build your VulnerabilityFinding from the Vulnerability data
					vulnerabilityFinding := VulnerabilityFinding{
						ID:                      id,
						Name:                    vuln.Name,
						DetailedName:            item.Name,
						ExternalDetectionSource: item.DetectionMethod,
						Severity:                vuln.Severity,
						ExternalFindingLink:     vuln.Source,
						Version:                 item.Version,
						Source:                  "wizcli",
						Remediation:             vuln.FixedVersion,
						FixedVersion:            vuln.FixedVersion,
						ValidatedAtRuntime:      false,
						Description:             description,
					}
					// Append the vulnerabilityFinding to the asset's VulnerabilityFindings slice
					asset.VulnerabilityFindings = append(asset.VulnerabilityFindings, vulnerabilityFinding)
				}
			}
		}
	}

	// After the loop, add the asset with all vulnerabilities to the dataSource
	dataSource.Assets = append(dataSource.Assets, asset)

	// Add the dataSource to the vulnerabilityOutput
	vulnerabilityOutput.DataSources = append(vulnerabilityOutput.DataSources, dataSource)

	return vulnerabilityOutput, nil
}
